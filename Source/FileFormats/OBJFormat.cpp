#include "OBJFormat.h"

using namespace MeshWarrior;

OBJFormat::OBJFormat()
{
	this->data = new Data();
	this->totalVertices = 0;
	this->totalFaces = 0;
}

/*virtual*/ OBJFormat::~OBJFormat()
{
	delete this->data;
}

/*virtual*/ std::string OBJFormat::SupportedExtension()
{
	return "OBJ";
}

/*virtual*/ bool OBJFormat::Load(const std::string& meshFile, std::vector<FileObject*>& fileObjectArray)
{
	std::ifstream fileStream(meshFile, std::ios::in);
	if (fileStream.is_open())
	{
		this->data->pointArray.clear();
		this->data->normalArray.clear();
		this->data->colorArray.clear();
		this->data->texCoordsArray.clear();
		this->data->polygonArray.clear();
		this->data->name = "?";
		
		std::string line;
		while (std::getline(fileStream, line))
		{
			std::vector<std::string> tokenArray;
			this->TokenizeLine(line, ' ', tokenArray, true);
			this->ProcessTokenizedLine(tokenArray, fileObjectArray);
		}

		this->FlushMesh(fileObjectArray);

		fileStream.close();
	}

	return true;
}

void OBJFormat::TokenizeLine(const std::string& line, char delimeter, std::vector<std::string>& tokenArray, bool stripEmptyTokens)
{
	std::stringstream stringStream(line);
	std::string token;
	while (std::getline(stringStream, token, delimeter))
		if(!stripEmptyTokens || token.size() > 0)
			tokenArray.push_back(token);
}

void OBJFormat::ProcessTokenizedLine(const std::vector<std::string>& tokenArray, std::vector<FileObject*>& fileObjectArray)
{
	if (tokenArray.size() == 0 || tokenArray[0] == "#")
		return;
	
	if (tokenArray[0] == "v")
	{
		Vector point;
		point.x = (tokenArray.size() > 1) ? ::atof(tokenArray[1].c_str()) : 0.0;
		point.y = (tokenArray.size() > 2) ? ::atof(tokenArray[2].c_str()) : 0.0;
		point.z = (tokenArray.size() > 3) ? ::atof(tokenArray[3].c_str()) : 0.0;
		this->data->pointArray.push_back(point);
	}
	else if (tokenArray[0] == "vt")
	{
		Vector texCoords;
		texCoords.x = (tokenArray.size() > 1) ? ::atof(tokenArray[1].c_str()) : 0.0;
		texCoords.y = (tokenArray.size() > 2) ? ::atof(tokenArray[2].c_str()) : 0.0;
		texCoords.z = (tokenArray.size() > 3) ? ::atof(tokenArray[3].c_str()) : 0.0;
		this->data->texCoordsArray.push_back(texCoords);
	}
	else if (tokenArray[0] == "vn")
	{
		Vector normal;
		normal.x = (tokenArray.size() > 1) ? ::atof(tokenArray[1].c_str()) : 0.0;
		normal.y = (tokenArray.size() > 2) ? ::atof(tokenArray[2].c_str()) : 0.0;
		normal.z = (tokenArray.size() > 3) ? ::atof(tokenArray[3].c_str()) : 0.0;
		this->data->normalArray.push_back(normal);
	}
	else if (tokenArray[0] == "f" && tokenArray.size() > 1)
	{
		Mesh::ConvexPolygon polygon;
		
		for (const std::string& token : tokenArray)
		{
			if (token == "f")
				continue;

			std::vector<std::string> vertexTokenArray;
			this->TokenizeLine(token, '/', vertexTokenArray, false);

			Mesh::Vertex vertex;

			int point_i = (vertexTokenArray.size() > 0 && vertexTokenArray[0].size() > 0) ? ::atoi(vertexTokenArray[0].c_str()) : INT_MAX;
			int texCoords_i = (vertexTokenArray.size() > 1 && vertexTokenArray[1].size() > 0) ? ::atoi(vertexTokenArray[1].c_str()) : INT_MAX;
			int normal_i = (vertexTokenArray.size() > 2 && vertexTokenArray[2].size() > 0) ? ::atoi(vertexTokenArray[2].c_str()) : INT_MAX;

			this->LookupAndAssign(this->data->pointArray, point_i, vertex.point);
			this->LookupAndAssign(this->data->texCoordsArray, texCoords_i, vertex.texCoords);
			this->LookupAndAssign(this->data->normalArray, normal_i, vertex.normal);

			polygon.vertexArray.push_back(vertex);
		}

		this->data->polygonArray.push_back(polygon);
	}
	else if (tokenArray[0] == "g" && tokenArray.size() > 1)
	{
		this->FlushMesh(fileObjectArray);
		this->data->name = tokenArray[1];
	}
}

void OBJFormat::FlushMesh(std::vector<FileObject*>& fileObjectArray)
{
	if (this->data->polygonArray.size() > 0)
	{
		Mesh* mesh = new Mesh();
		*mesh->name = this->data->name;
		mesh->FromPolygonArray(this->data->polygonArray);
		fileObjectArray.push_back(mesh);
		this->data->polygonArray.clear();
	}
}

void OBJFormat::LookupAndAssign(const std::vector<Vector>& vectorArray, int i, Vector& result)
{
	if (vectorArray.size() > 0 && i != INT_MAX)
	{
		// 1, 2, 3, ... becomes 0, 1, 2, ...
		// -1, -2, -3, ... becomes N-1, N-2, N-3, ...
		if (i > 0)
			i--;
		else if (i < 0)
			i = (int)vectorArray.size() + i;

		// Clamp the offset to be in range.
		if (i < 0)
			i = 0;
		else if (i >= (signed)vectorArray.size())
			i = (int)vectorArray.size() - 1;

		result = vectorArray[i];
	}
}

/*virtual*/ bool OBJFormat::Save(const std::string & meshFile, const std::vector<FileObject*>&fileObjectArray)
{
	std::ofstream fileStream(meshFile);
	if (!fileStream.is_open())
		return false;

	fileStream << "#\n";
	fileStream << "# Generated by MeshWarrior!\n";
	fileStream << "#\n\n";

	this->totalVertices = 0;
	this->totalFaces = 0;

	for (const FileObject* fileObject : fileObjectArray)
	{
		const Mesh* mesh = dynamic_cast<const Mesh*>(fileObject);
		if (mesh)
			this->DumpMesh(fileStream, mesh);

		const Polyline* polyline = dynamic_cast<const Polyline*>(fileObject);
		if (polyline)
			this->DumpPolyline(fileStream, polyline);
	}

	fileStream << "# Total vertices: " << this->totalVertices << "\n";
	fileStream << "# Total faces:    " << this->totalFaces << "\n";

	fileStream.close();
	return true;
}

void OBJFormat::DumpMesh(std::ofstream& fileStream, const Mesh* mesh)
{
	for (int i = 0; i < mesh->GetNumVertices(); i++)
	{
		// TODO: Output vertex colors too?
		const Mesh::Vertex* vertex = mesh->GetVertex(i);
		fileStream << "v " << vertex->point.x << " " << vertex->point.y << " " << vertex->point.z << "\n";
	}

	fileStream << "\n";

	for (int i = 0; i < mesh->GetNumVertices(); i++)
	{
		const Mesh::Vertex* vertex = mesh->GetVertex(i);
		fileStream << "vt " << vertex->texCoords.x << " " << vertex->texCoords.y << " " << vertex->texCoords.z << "\n";
	}

	fileStream << "\n";

	for (int i = 0; i < mesh->GetNumVertices(); i++)
	{
		const Mesh::Vertex* vertex = mesh->GetVertex(i);
		fileStream << "vn " << vertex->normal.x << " " << vertex->normal.y << " " << vertex->normal.z << "\n";
	}

	fileStream << "\n";
	fileStream << "g " << mesh->name->c_str() << "\n\n";

	for (int i = 0; i < mesh->GetNumFaces(); i++)
	{
		const Mesh::Face* face = mesh->GetFace(i);
		if (face->vertexArray.size() >= 3)
		{
			fileStream << "f ";

			for (int j = 0; j < (signed)face->vertexArray.size(); j++)
			{
				int vertex_i = this->totalVertices + face->vertexArray[j] + 1;		// Needs to be 1-based, not 0-based.
				fileStream << vertex_i << "/" << vertex_i << "/" << vertex_i << " ";
			}

			fileStream << "\n";
		}
	}

	fileStream << "\n";

	this->totalVertices += mesh->GetNumVertices();
	this->totalFaces += mesh->GetNumFaces();
}

void OBJFormat::DumpPolyline(std::ofstream& fileStream, const Polyline* polyline)
{
	for (int i = 0; i < (int)polyline->vertexArray->size(); i++)
	{
		const Vector& vertex = (*polyline->vertexArray)[i];
		fileStream << "v " << vertex.x << " " << vertex.y << " " << vertex.z << "\n";
	}

	fileStream << "\nl";

	for (int i = 0; i < (int)polyline->vertexArray->size(); i++)
		fileStream << " " << i + this->totalVertices + 1;

	fileStream << "\n\n";

	this->totalVertices += (int)polyline->vertexArray->size();
}